module ARMA

using Polynomials, NLsolve, HDF5
using LinearAlgebra
using Statistics
using ToeplitzMatrices

export
    estimate_covariance,
    fitARMA,
    fit_exponentials,
    ARMAModel,
    generate_noise,
    model_covariance,
    model_psd,
    ARMASolver,
    whiten,
    unwhiten,
    mult_covariance,
    solve_covariance,
    inverse_covariance,
    toeplitz_whiten,
    PartialFracRational,
    BarycentricRational

# ARMA.jl includes the basic ARMA models and their use
# model_selection.jl includes tools for choosing a model (p,q) order
#   and for fitting the best model of that order.

include("model_selection.jl")
include("psd_model_fitting.jl")


"""
    ARMAModel(...)

An Autoregressive Moving-Average model of order (p,q).

There are four alternative ways to construct the model:

1. `ARMAModel(θcoef::AbstractVector, ϕcoef::AbstractVector)` (either argument or both may be a
    `Polynomials.AbstractPolynomial` instead of a `AbstractVector`)
2. `ARMAModel(zroots::AbstractVector, poles::AbstractVector, inputvariance::Float64)`
3. `ARMAModel(bases::AbstractVector, amplitudes::AbstractVector, covarianceIV::AbstractVector)`
4. `ARMAModel(psd::PartialFracRational)`

The first method specifies the model by the coefficients of its rational
function representation in "z space". The ordering of the coefficients is constant first,
high-order last: `c[1]+c[2]*z+c[3]*z^2...` Here, `θcoef` represents the
numerator of the forward transform and `ϕcoef` the denominator. By convention,
the value `ϕcoef[1]` is 1.0, but both polynomials will be rescaled to achieve
this before calling the inner constructor. To ensure a stable, invertible ARMA
model, the roots of both polynomials should have absolute values greater than 1.
Either argument or both may be of type `Polynomials.AbstractPolynomial`, in which case
the polynomial coefficients will be used.

The second method specifies the model by the z-space roots and poles of its rational
function representation, along with a variance of the input (white noise) process.
The latter is necessary to specify the overall scale of the model, because roots
and poles are insensitive to scale. All roots and poles must have absolute value
greater than 1, to ensure a stable and invertible ARMA model.

The third specifies the model by its covariance function, represented as a sum
of (potentially complex) exponentials, with 0 or more initial values of the
covariance (`covarianceIV`) that violate the general pattern.  For `ARMAModel(b,
a, cIV)`, the covariance at lag `j-1` is either `cIV[j]` when `j≤length(cIV)`,
or else `sum(b .* (a.^t))`. For any base and amplitude pair (bi,ai) where either
has a non-zero imaginary part, it is required that (conj(bi),conj(ai)) also be
among the base and amplitude pairs. This requirement ensures that the covariance
is everywhere real. Also, we require `|b|<1` for all bases to ensure a stable
model. Beware of supplying a longer-than-necessary `cIV`. Trailing zeros
are truncated, but trailing small-but-nonzero values increase the MA order with
little effect.

The fourth specifies the model by its power spectral density, represented as
a partial fraction in `z=cos(ω)`, where ω=π corresponds to the critical (Nyquist)
frequency. This partial fraction must be finite and strictly positive for all values
ω∈[0,π].

Methods 1 and 2 can create ARMA(p,q) models of arbitrary order. A pure AR(p)
model with q=0 can be generated by passing `θcoef` of length 1 or
`zroots=[]` to the methods 1 and 2 constructors, respectively. Similarly, a pure
MA(q) model with p=0 can be generated using `ϕcoef` of length 1 or `poles=[]`.
Method 3 generates an ARMA(p,q) model where p is the length of both the `bases`
and `amplitudes` vectors, and where `q=p-1+length(covarianceIV)`.  Method 4 generates
an ARMA(p,q) model where `p` is the number of terms in the partial fraction, and `q-p` is
the degree of the remainder polynomial. While models of MA order `q<p-1` are possible in
principle, they are not well-matched to the sum-of-exponentials or partial fraction
representations, because setting `q<p-1` imposes complicated
restrictions on the relative amplitudes of the exponentials or of the partial fractions.

When an `ARMAModel` is constructed by any of these methods, all
representations are computed and stored.

See also: [`ARMASolver`](@ref) for fast mutliplies and solves of either the
noise model covariance matrix or its Cholesky factor.
"""
mutable struct ARMAModel
    p         ::Int
    q         ::Int
    zroots    ::Vector{ComplexF64}
    zpoles    ::Vector{ComplexF64}
    cosroots  ::Vector{ComplexF64}
    cospoles  ::Vector{ComplexF64}
    θcoef     ::Vector{Float64}
    ϕcoef     ::Vector{Float64}
    covarIV   ::Vector{Float64}
    expbases  ::Vector{ComplexF64}
    expampls  ::Vector{ComplexF64}
    psdmodel  ::PartialFracRational

    function ARMAModel(zroots,zpoles,θcoef,ϕcoef,covarIV,expbases,expampls,psdmodel)
        p = length(zpoles)
        q = length(zroots)
        @assert all(abs2.(zpoles) .> 1)
        @assert all(abs2.(zroots) .> 1)
        @assert p+1 == length(ϕcoef)
        @assert q+1 == length(θcoef)
        @assert p == length(expbases)
        @assert p == length(expampls)
        @assert length(covarIV) ≥ 1+q-p
        θcoef = real(θcoef)
        ϕcoef = real(ϕcoef)
        length(θcoef) > 0 && @assert θcoef[1] > 0
        length(ϕcoef) > 0 && @assert ϕcoef[1] == 1.0
        # Note that the consistency checks above don't cover everything. Specifically, we
        # do _not_ test the consistency of the 4 representations with each other. That's
        # done only in the outer constructors.

        cosroots = (zroots + 1.0 ./zroots)/2
        cospoles = (zpoles + 1.0 ./zpoles)/2
        new(p,q,zroots,zpoles,cosroots,cospoles,θcoef,ϕcoef,covarIV,expbases,expampls,psdmodel)
    end
end


function Base.show(io::IO, m::ARMAModel)
    print(io, "ARMAModel(p=$(m.p), q=$(m.q))\n")
    print(io, "[Amplitude, Exponential base]\n")
    for i=1:m.p
        print(io, "(A,B)[$i]: $(m.expampls[i]),  $(m.expbases[i])\n")
    end
    print(io, "Initial covar: $(m.covarIV)\n")
end

"""
    rpv2spectrum(zroots::AbstractVector, zpoles::AbstractVector, f0::Real=1.0)

Generate the spectral density function given the roots and poles, and the scaling
factor `f0`, which is the spectral density at ω=0.
"""
function rpv2spectrum(zroots::AbstractVector, zpoles::AbstractVector, f0::Real=1.0)
    p = length(zpoles)
    q = length(zroots)
    @assert q≥0 && p≥0
    @assert p+q>0

    Bcols = max(q-p+1, 0)
    cosroots = (zroots .+ 1.0 ./ zroots)/2
    cospoles = RCPRoots((zpoles .+ 1.0 ./ zpoles)/2)
    a = b = Float64[]
    T = promote_type(eltype(zroots), eltype(zpoles))

    n_invented = 0
    if q < p-1  # There are not enough roots to find coeffients as null space of [A B]
        n_invented = p-1-q
        invented_roots = LinRange(-1, 1, p+1-q)[2:end-1]
        append!(cosroots, invented_roots)
    end

    qplus = length(cosroots)  # The effective number of roots, when the invented ones are included.
    A = zeros(T, qplus, p)
    for (i, cr_i) = enumerate(cosroots)
        for j=1:p
            A[i,j] = 1.0 / (cr_i-cospoles[j])
        end
    end
    B = zeros(T, qplus, Bcols)
    if Bcols > 0
        coef = [1.0]
        for j=0:Bcols-1
            # Create Chebyshev T_j function
            Tj = ChebyshevT(coef)
            B[:,j+1] = evalpoly.(cosroots, Tj, false)
            coef = [0.0, coef...]
        end
    end
    ab = nullspace([A B])
    a = ab[1:p]
    b = ab[p+1:end]

    # If there are invented (fake) roots, remove them now
    if n_invented > 0
        @assert Bcols == 0
        invented_roots = cosroots[q+1:end]
        cosroots = cosroots[1:q]
        for j=1:p
            a[j] /= prod(cospoles[j].-invented_roots)
        end
    end

    # Careful! this_f0 might be complex, b/c the nullspace(...) call might have unwanted phase.
    this_f0 = sum(a ./ (1.0 .-cospoles))+sum(b)
    rescale = f0/this_f0
    b = real(b*rescale)
    # a *= rescale is what we want, but be careful with angles and what's truly real, and
    # make conjugate pairs be true conjugate pairs.
    ρ = abs.(a)*abs(rescale)
    θ = angle.(a).+angle(rescale)
    a = ρ.*exp.(θ*1im)
    for i=1:2:ncomplex(cospoles)
        ra = real(sum(a[i:i+1]))/2
        ia = imag(a[i]-a[i+1])/2
        a[i] = ra+ia*1im
        a[i+1] = conj(a[i])
    end
    for i=ncomplex(cospoles)+1:p
        a[i] = real(a[i])
    end
    PartialFracRational(cospoles.z, a, b)
end

# Construct from θ and ϕ polynomial representation, either as polynomials or coefficients thereof
ARMAModel(θ::AbstractVector, ϕ::AbstractVector) = ARMAModel(Polynomial(θ), Polynomial(ϕ))
ARMAModel(θ::AbstractPolynomial, ϕ::AbstractVector) = ARMAModel(θ, Polynomial(ϕ))
ARMAModel(θ::AbstractVector, ϕ::AbstractPolynomial) = ARMAModel(Polynomial(θ), ϕ)
function ARMAModel(θ::AbstractPolynomial, ϕ::AbstractPolynomial)
    zroots = roots(θ)
    zpoles = roots(ϕ)
    θcoef = θ.coeffs
    ϕcoef = ϕ.coeffs
    # Normalize the input coefficient vectors
    θcoef ./= ϕcoef[1]
    if θcoef[1] < 0
        θcoef = -θcoef
    end
    ϕcoef ./= ϕcoef[1]
    @assert all(abs2.(zroots) .> 1)
    @assert all(abs2.(zpoles) .> 1)

    # Make a PSD model, scaled to f(ω=0) = f0.
    f0 = abs2(sum(θcoef)/sum(ϕcoef))/2π
    psdmodel = rpv2spectrum(zroots, zpoles, f0)
    covarIV, expbases, expampls = spectrum2covar(psdmodel)
    ARMAModel(zroots,zpoles,θcoef,ϕcoef,covarIV,expbases,expampls,psdmodel)
end

WhiteModel() = ARMAModel([1.0], [1.0])

"Form the coefficients of a polynomial from the given roots `r`.
It is assumed that the coefficients are real, so only the real part is kept.
The lowest-order nonzero term (generically, the first) has coefficient +1."
function polynomial_from_roots(r::AbstractVector)
    pr = prod(r)
    @assert abs(sin(angle(pr))) < 1e-10
    n0 = sum(r.==0) # count number of identically zero roots.
    coef = real(fromroots(r).coeffs)
    coef / coef[1+n0]
end


# Construct from roots-and-poles representation. We also need σ^2 value
# (the input process variance) to set the scale of the model, as roots-and-poles omits this.
function ARMAModel(zroots::AbstractVector, zpoles::AbstractVector, inputvariance::Real)
    @assert all(abs2.(zroots) .> 1)
    @assert all(abs2.(zpoles) .> 1)
    # The product of the roots and the product of the poles needs to be real.
    # That's a necessary, but not sufficient, condition.
    pr = prod(zroots)
    pp = prod(zpoles)
    @assert abs(imag(pr)/real(pr)) < 1e-10
    @assert abs(imag(pp)/real(pp)) < 1e-10
    zroots = RCPRoots(zroots)
    zpoles = RCPRoots(zpoles)

    # Construct normalized MA and AR polynomials.
    # Note that we will NOT have the proper scale at first.
    θcoef = polynomial_from_roots(zroots)*sqrt(inputvariance)
    ϕcoef = polynomial_from_roots(zpoles)

    # Scale the PSD model to have f(ω=0)=f0.
    f0 = abs2(sum(θcoef)/sum(ϕcoef))/2π
    psdmodel = rpv2spectrum(zroots, zpoles, f0)
    covarIV, _, _ = spectrum2covar(psdmodel)
    f1 = real(psdmodel(1))

    covarIV, expbases, expampls = spectrum2covar(psdmodel)
    ARMAModel(zroots,zpoles,θcoef,ϕcoef,covarIV,expbases,expampls,psdmodel)
end


function covar2spectrum(covarIV::AbstractVector, bases::AbstractVector, amplitudes::AbstractVector)
    @assert length(bases) == length(amplitudes)
    if length(bases) == 0
        bases = Float64[]
        amplitudes = Float64[]
    end
    zpoles = 1.0 ./ bases
    cospoles = (zpoles .+ 1.0 ./zpoles)/2
    a = -amplitudes .* (zpoles .- 1. ./zpoles)/4π
    if length(covarIV) == 0
        return PartialFracRational(cospoles, a)
    end

    # Reduce MA order by deleting any trailing elements that are strictly zero.
    civ = copy(covarIV)
    while civ[end] == 0
        pop!(civ)
    end
    for i=1:length(a)
        civ .-= real(amplitudes[i]*(bases[i].^(0:length(civ)-1)))
    end
    b = civ/π
    b[1] = b[1]/2
    PartialFracRational(cospoles, a, b)
end

function spectrum2covar(spectrum::PartialFracRational)
    p = length(spectrum.λ)
    q = length(spectrum.b)+p-1
    cospoles = spectrum.λ
    zpoles = RCPRoots(exp.(acosh.(complex(cospoles))))
    if eltype(cospoles) <: Real
        zpoles = real(zpoles)
    end
    bases = 1.0 ./ zpoles
    amplitudes = -4π*spectrum.a ./ (zpoles .- 1.0 ./ zpoles)

    # Get amplitudes to be cc pairs or real
    for i=1:2:ncomplex(zpoles)
        ra = real(sum(amplitudes[i:i+1]))/2
        ia = imag(amplitudes[i]-amplitudes[i+1])/2
        amplitudes[i] = ra+1im*ia
        amplitudes[i+1] = conj(amplitudes[i])
    end
    for i=1+ncomplex(zpoles):p
        amplitudes[i] = real(amplitudes[i])
    end

    covarIV = zeros(Float64, q+1)
    covarIV[1:q+1-p] .= π*real(spectrum.b)
    covarIV[1] *= 2
    for i=1:spectrum.n
        covarIV .+= real(amplitudes[i]*(bases[i].^(0:length(covarIV)-1)))
    end
    covarIV, bases, amplitudes
end

# Construct ARMAModel from a sum-of-exponentials representation, along with
# zero or more exceptional values of the initial covariance, covarIV.
# It is allowed for covarIV=[], but it can't be optional,
# else this constructor will get mixed up with the (θcoef,ϕcoef) one.
# The model will have order ARMA(p,q) where p=length(bases)=length(amplitudes),
# and q=p-1+length(covarIV).

function ARMAModel(bases::AbstractVector, amplitudes::AbstractVector, covarIV::AbstractVector)
    @assert length(bases) == length(amplitudes)
    @assert eltype(covarIV) <: Real

    psdmodel = covar2spectrum(covarIV, bases, amplitudes)

    cosroots = find_roots(psdmodel)
    zroots = exp.(acosh.(complex(cosroots)))
    zpoles = 1.0 ./ bases
    ϕcoef = polynomial_from_roots(zpoles)
    θcoef = polynomial_from_roots(zroots)
    f0 = psdmodel(1) # i.e., at cos ω=1.0 or ω=0.
    this_f0 = abs2(sum(θcoef)/sum(ϕcoef))/2π
    θcoef *= sqrt(f0/this_f0)

    ARMAModel(zroots,zpoles,θcoef,ϕcoef,covarIV,bases,amplitudes,psdmodel)
end

# Construct ARMAModel from a partial-fraction representation of its power spectral density.

function ARMAModel(psdmodel::PartialFracRational)
    covarIV, bases, amplitudes = spectrum2covar(psdmodel)
    cospoles = psdmodel.λ
    cosroots = find_roots(psdmodel)
    zpoles = exp.(acosh.(complex(cospoles)))
    zroots = exp.(acosh.(complex(cosroots)))
    ϕcoef = polynomial_from_roots(zpoles)
    θcoef = polynomial_from_roots(zroots)
    f0 = psdmodel(1) # i.e., at cos ω=1.0 or ω=0.
    this_f0 = abs2(sum(θcoef)/sum(ϕcoef))/2π
    θcoef *= sqrt(f0/this_f0)

    ARMAModel(zroots,zpoles,θcoef,ϕcoef,covarIV,bases,amplitudes,psdmodel)
end


"""
    hdf5save(output, model::ARMAModel)

Store the `model` to an HDF5 file.

`output` may be an HDF5 file open for writing, an HDF5 group within such a file,
or the file name of an HDF5 file which will be created.
"""
function hdf5save(output::HDF5.H5DataStore, model::ARMAModel)
    GROUPNAME = "ARMAModel"
    if haskey(output, GROUPNAME)
        o_delete(output, GROUPNAME)
    end
    grp = create_group(output, GROUPNAME)
    grp["basesR"] = real(model.expbases)
    grp["basesI"] = imag(model.expbases)
    grp["amplitudesR"] = real(model.expampls)
    grp["amplitudesI"] = imag(model.expampls)
    grp["covarIV"] = model.covarIV[1:max(model.p, model.q+1)-model.p]
    model
end

function hdf5save(filename::AbstractString, model::ARMAModel)
    h5open(filename, "w") do f
        hdf5save(f, model)
    end
end


"""
    model = hdf5load(input)

Load and return an `ARMAModel` object from `input`. The argument `input` can be
the "ARMAModel" group, the group that contains it, or the name of an HDF5 file
(group "ARMAModel" would need to be at the root of the file).
"""
function hdf5load(input::HDF5.H5DataStore)
    if haskey(input, "ARMAModel")
        return hdf5load(input["ARMAModel"])
    end
    bases = input["basesR"][:] + 1im*input["basesI"][:]
    ampls = input["amplitudesR"][:] + 1im*input["amplitudesI"][:]
    covarIV = input["covarIV"][:]

    ARMAModel(bases, ampls, covarIV)
end

function hdf5load(filename::AbstractString)
    h5open(filename, "r") do f
        return hdf5load(f)
    end
end


"""
    generate_noise(m, N)

Generate a simulated noise timeseries of length `N` from an ARMAModel `m`.
"""
function generate_noise(m::ARMAModel, N::Int)
    # eps = white N(0,1) noise; x = after MA process; z = after inverting AR
    eps = randn(N+m.q)
    eps[1:m.p] = 0
    x = fill(0.0, N)
    z = fill(0.0, N)
    for i=1:m.q+1
        x += eps[i:end+i-m.p-1] * m.θcoef[i]
    end
    for j=1:m.p
        z[j] = x[j]
        for i = 2:j
            z[j] -= m.ϕcoef[i] * z[j-i+1]
        end
    end
    for j=1+m.p:N
        z[j] = x[j]
        for i = 2:m.p+1
            z[j] -= m.ϕcoef[i] * z[j-i+1]
        end
    end
    z
end



"""
    model_covariance(...)

Compute the ARMA model's model covariance function. Methods:

1. `model_covariance(m::ARMAModel, N::Int)`
2. `model_covariance(covarIV::Vector, ϕcoef::Vector, N::Int)`

The first returns covariance of model `m` from lags 0 to `N-1`. The second
returns the covariance given the initial exceptional values of covariance
`covarIV` and the coefficients `ϕcoef` of the Phi polynomial. (From these
coefficients, a recusion allows computation of covariance beyond the initial
values.)
"""
function model_covariance(covarIV::AbstractVector, ϕcoef::AbstractVector, N::Int)
    if N < length(covarIV)
        return covarIV[1:N]
    end
    @assert(length(covarIV) ≥ length(ϕcoef)-1)
    if ϕcoef[1] != 1.0
        ϕcoef = ϕcoef/ϕcoef[1]
    end
    covar = fill(0.0, N)
    covar[1:length(covarIV)] = covarIV[1:end]

    # Use Pollock eq 17.86
    for i = length(covarIV)+1:N
        for j = 1:length(ϕcoef)-1
            covar[i] -= ϕcoef[j+1] * covar[i-j]
        end
    end
    covar
end

function model_covariance(m::ARMAModel, N::Int) #  = model_covariance(m.covarIV, m.ϕcoef, N)
    nSpecialVals = length(m.covarIV)
    if N ≤ nSpecialVals
        return m.covarIV[1:N]
    end
    covar = zeros(Float64, N)
    for (a,b) in zip(m.expampls, m.expbases)
        pseries = b.^(0:N-1)
        covar += real(a*pseries)
    end
    covar[1:nSpecialVals] .= m.covarIV
    covar
end


"""
    model_psd(m,...)

The ARMA model's power spectral density function. Methods:

1. `model_psd(m::ARMAModel, freq)` (`freq` is a real number or vector of them)
1. `model_psd(m::ARMAModel, N::Int)`

The first returns PSD at the given frequency or frequencies `freq` (frequency 0.5
is the critical, or Nyquist, frequency). The second returns PSD at `N`
equally-spaced frequencies from 0 to 0.5.
"""
model_psd(m::ARMAModel, freq::Real) = real(m.psdmodel(cos(2π*freq)))
model_psd(m::ARMAModel, freq::AbstractVector) = real(m.psdmodel.(cos.(2π*freq)))
model_psd(m::ARMAModel, N::Int) = model_psd(m, LinRange(0, 0.5, N))


"""
    toeplitz_whiten(m, timestream)

Approximately whiten the timestream using a Toeplitz matrix. This has the
consequence that a zero-padded delay of the input timestream is equivalent to a
zero-padded delay of the output.

Returns the whitened timestream.

If `timestream` is a matrix, then each column is whitened, and the result is
returned.

No Toeplitz matrix has the ability to make the input exactly white,
but for many purposes, the time-shift property is more valuable than
that exact whitening.
"""
function toeplitz_whiten(m::ARMAModel, timestream::AbstractVector)
    N = length(timestream)
    white = fill(0.0, N)

    # First, multiply the input by the AR matrix (a banded Toeplitz
    # matrix with the ϕ coefficients on the diagonal and first p
    # subdiagonals).
    # The result is the MA matrix times the whitened data.
    MAonly = m.ϕcoef[1] * timestream
    for i=1:m.p
        MAonly[1+i:end] .+= m.ϕcoef[i+1] * timestream[1:end-i]
    end

    # Second, solve the MA matrix (also a banded Toeplitz matrix with
    # q non-zero subdiagonals.)
    white[1] = MAonly[1] / m.θcoef[1]
    if N==1
        return white
    end
    for i = 2:min(m.q, N)
        white[i] = MAonly[i]
        for j = 1:i-1
            white[i] -= white[j]*m.θcoef[1+i-j]
        end
        white[i] /= m.θcoef[1]
    end
    for i = m.q+1:N
        white[i] = MAonly[i]
        for j = i-m.q:i-1
            white[i] -= white[j]*m.θcoef[1+i-j]
        end
        white[i] /= m.θcoef[1]
    end
    white
end

function toeplitz_whiten(m::ARMAModel, M::AbstractMatrix)
    tw(v::AbstractVector) = toeplitz_whiten(m, v)
    mapslices(tw, M, dims=1)
end


include("exact_operations.jl")

end # module
